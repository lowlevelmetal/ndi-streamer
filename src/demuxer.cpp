/**
 * @file demuxer.cpp
 * @brief This file includes utilities for demuxing media files.
 * @date 2024-09-04
 * @author Matthew Todd Geiger
 */

#include "demuxer.hpp"
#include "macro.hpp"

/**
 * @brief The AV::Utils namespace contains utilities for audio and video processing.
 */
namespace AV::Utils {

/**
 * @brief Get the AVStream pointers that were generated by ffmpeg.
 * This is useful for getting the stream information inexpensively
 * but keep in mind that the AVStream pointers are owned by the Demuxer object.
 *
 * @return std::vector<AVStream *>
 */
std::vector<AVStream *> Demuxer::GetStreamPointers() {
    FUNCTION_CALL_DEBUG();

    std::vector<AVStream *> streams;

    for (unsigned int i = 0; i < m_format_ctx->nb_streams; i++) {
        streams.push_back(m_format_ctx->streams[i]);
    }

    return streams;
}

/**
 * @brief Read the next frame from the media file.
 *
 * @return ReadFrameResult
 */
ReadFrameResult Demuxer::ReadFrame() {
    FUNCTION_CALL_DEBUG();

    // Reset the packet to default values
    av_packet_unref(m_packet);

    // Read the next frame
    int ret = av_read_frame(m_format_ctx, m_packet);
    if (ret < 0) {
        PRINT_FFMPEG_ERR(ret);

        // If eof return a different error
        if(ret == AVERROR_EOF) {
            return {nullptr, AvError::DEMUXEREOF};
        }

        return {nullptr, AvException(AvError::READFRAME)};
    }

    return {m_packet, AvException(AvError::NOERROR)};
}

/**
 * @brief Create a Demuxer object
 *
 * @param path path to media file
 * @return DemuxerResult
 */
DemuxerResult Demuxer::Create(const std::string &path) {
    FUNCTION_CALL_DEBUG();

    AvException error;

    // Catching errors from the constructor is important.
    // I don't trust software engineers to do it correctly.
    // So I'm going to do it for them.
    // You're welcome.
    try {
        return {std::unique_ptr<Demuxer>(new Demuxer(path)), AvException(AvError::NOERROR)};
    } catch (AvException err) {
        DEBUG("Demuxer error: %s", err.what());
        error = err;
    }

    return {nullptr, error};
}

/**
 * @brief Construct a new Demuxer:: Demuxer object
 *
 * @param path path to media file
 */
Demuxer::Demuxer(const std::string &path) : m_path(path) {
    FUNCTION_CALL_DEBUG();

    AvError err = m_Initialize();
    if (err != AvError::NOERROR) {
        throw err; // you can throw the error code because the compiler is smart enough to call the constructor
    }
}

/**
 * @brief Destroy the Demuxer:: Demuxer object
 */
Demuxer::~Demuxer() {
    FUNCTION_CALL_DEBUG();

    // Free the packet
    if (m_packet != nullptr) {
        av_packet_free(&m_packet);
        DEBUG("av_packet_free called");
    }

    // Destroy the format context
    if (m_format_ctx != nullptr) {
        avformat_close_input(&m_format_ctx);
        DEBUG("avformat_close_input called");
    }
}

/**
 * @brief Initialize the demuxer
 *
 * @return AvError
 */
AvError Demuxer::m_Initialize() {
    FUNCTION_CALL_DEBUG();

    // Create the format context
    int ret = avformat_open_input(&m_format_ctx, m_path.c_str(), nullptr, nullptr);
    if (ret < 0) {
        DEBUG("avformat_open_input failed");
        PRINT_FFMPEG_ERR(ret);
        return AvError::OPENINPUT;
    }

    // Create the packet
    m_packet = av_packet_alloc();
    if (!m_packet) {
        DEBUG("av_packet_alloc failed");
        return AvError::PACKETALLOC;
    }

    // Load the stream information into the format context
    ret = avformat_find_stream_info(m_format_ctx, nullptr);
    if (ret < 0) {
        DEBUG("avformat_find_stream_info failed");
        PRINT_FFMPEG_ERR(ret);
        return AvError::FINDSTREAMINFO;
    }

    return AvError::NOERROR;
}

} // namespace AV::Utils